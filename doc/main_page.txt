/**
//@mainpage notitle
//
//@section dev_manual Developer's Manual
//
//@subsection intro Introduction
//
//===========================
//
//                           Mark Davis, NSCL/FRIB
//
//  @note  This is done in text format to make it easy to do a diff on it to
//         see what changed between versions.  The reason for making all lines
//         "comment" lines is so that editors that support some simple
//         formatting on comment blocks (such as the one I use: SlickEdit) can
//         be used to edit it while maintaining line breaks, indentations, etc.
//
//
//  Acronyms:
//     - ANL:   Argonne National Laboratory
//     - FRIB:  Facility for Rare Isotope Beams
//     - IOC:   Input/Output Controller
//     - NSCL:  National Superconducting Cyclotron Laboratory
//     - FGPDB: FRIB General Purpose Digital Board
//     - LLRF:  Low Level Radio Frequency
//     - LCP:   LLRF Control Protocol
//
//  The drvFGPDB is designed to be as generic as possible and work with all
//  devices that support LCP.  While the name came from the first use of this
//  protocol, the protocol itself is also very generic and makes very few
//  assumptions about the devices that support it.
//
//  The drvFGPDB class is the heart of the driver and is derived from the
//  asynPortDriver class that is part of the popular asyn package from ANL that
//  makes writing device support modules much simpler.  Unlike the orignal
//  version of the driver for LCP devices, it is very generic and can be used
//  without changes or additions for many different devices.
//
//===================================
//
//@subsection summary_LCP Summary of LCP
//
//===================================
//
//     LCP is designed to support the reading and writing of 32-bit scalar
//     values (referred to as registers) and arrays of 8-bit values.  The
//     register values are grouped in to 3 categories: Read-Only (RO),
//     Write-Anytime (WA), and Write-Once (WO).
//
//     One or more values can be read from the controller at any time, each
//     command reading up to the # of register values in each group.  LCP also
//     supports streaming connections, where the device can send packets
//     containing register values on a periodic basis and/or when values have
//     changed.
//
//     The current value of one or more registers can be read or written to at
//     any time, although each command is currently limited to a range of
//     register numbers within a group.
//
//     Write-Anytime registers are generally used for values that represent
//     level-triggered logic:  If a value written to one of these registers is
//     the same as the last value written, the state of the controller will not
//     change (e.g. a setpoint).
//
//     Write-Once registers are generally used for values that represent
//     edge-triggered logic:  Even if the value written to one of these
//     registers is the same as the last value written, it generally triggers
//     some processing and/or results in a change (possibly just temporary) in
//     the state of the controller (e.g. increment a count, recalibrate, update
//     a waveform value, etc.).
//
//     @note
//       At present, the driver assumes that the Write-Anytime registers
//       represents the set of values that should be saved and restored
//       whenever the controller or the IOC is restarted.  This means that, for
//       certain key values, even though they fit the general description for
//       write-anytime values, they often need to be part of the write-once
//       group instead.  The most common example is the on/off state.  While
//       having all the most recent settings for a controller automatically
//       restored after it is reset can be very helpful, allowing the control
//       system to automatically turn it back on is generally NOT what we want
//       to happen.
//
//     Of course, such decisions are entirely determined by the controller.
//     Using the on/off command as an example:  If the on/off command is part
//     of the write-once group, then the IOC will not reassert its last state
//     after a controller restart.  But unless the controller also includes an
//     interlock bit in some readable status register, then the only indication
//     that the controller turned off because it was restarted will be a
//     message in the IOC shell (and perhaps a log file), or the fact that the
//     amount of time since the controller was restarted changed to a smaller
//     value (assuming, of course, that this value is included in a user
//     interface and someone actually noticed the change).
//
//     What makes more sense is to include interlock logic in the controller
//     that includes setting a bit in a readable register to indicate when this
//     has occurred, and require that a value be written to a write-once
//     register to clear the interlock.  That would make it easy to include in
//     a user interface, and it would require someone to acknowledge the cause
//     before they could turn it back on.
//
//================================================
//
//@subsection driver_organization Driver Organization
//
//================================================
//
//     The asyn layer on which the driver is based provides a generic mechanism
//     between clients that need to interact with a device (in this case EPICS
//     records) and a driver that understands how to communicate with the
//     device.  The interface between the asyn layer and such drivers consists
//     of a set of parameters, each one representing either a scalar or array
//     of scalar values, and support for read and write operations on those
//     scalars.
//
//     The driver is responsible for creating the set of parameters during
//     initialization of the IOC, and then processing writes to the parameters
//     and updating the current value and state of each parameter as needed.
//     This generally requires that the driver communicates with one or more
//     devices on a frequent basis, and that it responds appropriately to any
//     problems that occur (e.g. com link problems, controller restarts, etc).
//
//     For each asyn parameter the driver creates, it also creates a
//     corresponding ParamInfo object which contains all the additional
//     information it needs to manage the state of each parameter.  This
//     information includes separate read and set values, related state
//     information, and what categories the value is part of, which determines
//     how reads and writes are processed.
//
//     The majority of the parameters are for values that are specific to a
//     particular device but are completely generic as far as the driver is
//     concerned and are handled entirely by its generic read/write logic. But
//     there are a few required values that each device must support for the
//     driver to operate.  And there are a few more that, while not critical to
//     the normal operation of the driver, provide useful diganostic
//     information and so are also included in the list of required values.
//
//==========================
//
//@subsection driver_Init Driver Initialization
//
//==========================
//
//     Each record that reads from or writes to an asyn param must specify
//     which asyn layer interface to use in its DTYP field and include a
//     compatible driver definition for the param in its INP or OUT field.  If
//     more than one record references the same field, the driver definitions
//     for the param must all be the same.
//
//     For each such record, the driver's drvUserCreate() function is called
//     during IOC initialization with the contents of the record's INP/OUT
//     field.  This string is parsed and, assuming it represents a valid
//     configuration for a parameter, then a new parameter is created (or
//     updated, if a previous call provided only a partial definition).
//
//     The EPICS initHook callback feature is used to determine when all the
//     parameters have been defined (i.e. any additional calls to
//     drvUserCreate() will be for existing, fully define parameters) and it is
//     safe to begin normal processing for the paramters.
//
//     @note
//        - The drvUserCreate() function is called multiple times for each
//          record during IOC init.  The reason for this is not clear, but is
//          presumably due to calls to the asyn layer during different steps in
//          the record initialization process.
//
//        - The driver assumes that the latest settings for most of the
//          write-anytime registers (and the driver-only ctlrUpSince value) is
//          automatically saved and restored across IOC restarts (using
//          autosave or some equivalent).  This allows the IOC to restore the
//          settings to the controller if needed, and minimizes the effect of
//          an IOC reboot.
//
//        - The first of the two phases in which autosave can be told to
//          restore values happens during the same PHASE that the first set of
//          calls to drvUserCreate() occur, but BEFORE the drvUserCreate()
//          calls occur.  This means that the first phase is useless, as it is
//          trying to write values to parameters that don't yet exist.
//          \n
//          BUT: Unless asyn is somehow postponing some standard processing
//          for record initialization, this seems like a basic flaw that allows
//          an attempt to write to records whose DTYP layer has not yet
//          finished initialization.  If true, it would mean that any record
//          that used DTYP to specify the driver type could have this problem.
//          \n
//        - There is currently no known way to determine what record the call
//          was for, or to get the DTYP or MTYP value for the record containing
//          the param definition.
//
//        - None of the calls to drvUserCreate() are from threads created by
//          the driver.  But since these calls occur BEFORE the driver actually
//          starts normal processing, there is currently no need to guard
//          against concurrency issues.
//
//
//==========================================
//
//@subsection normal_operation Normal Operation
//
//==========================================
//
//     The driver constructor currently creates a single thread that is
//     responsible for all the ongoing synchronous (polling) communication with
//     the controller. In the future, it will (optionally) create a second
//     thread to manage a separate streaming (asynchronous) connection to the
//     controller that allows the controller to send new data without being
//     asked for it each time.
//
//     Currently, the synchronous thread provides a simple scheduler that
//     periodically executes one or more run-to-completion tasks.  The interval
//     between each pass and what gets executed each pass can vary depending on
//     the outstanding tasks, allowing certain higher-priority tasks to run
//     sooner or more often as needed without adversely affecting normal
//     lower-priority tasks. In particular, write operations wake up this
//     thread early to insure new writes are processed ASAP, and unfinished
//     reads or writes for array values are processed more often than scalar
//     reads and writes.
//
//
//<h3> Write processing: </h3>
//
//     The driver uses the non-blocking mode option for the asyn layer.  This
//     has several advantages over using the blocking mode option:
//        - It avoids the overhead of having the asyn layer create a queue for
//          write operations and the additional thread per driver object to
//          process it.
//        - It means lengthy write operations (e.g. the current model of
//          updating the controller's firmware, which is to write the entire
//          image to a very large waveform record) do not block all other read
//          and write operations until they complete (or fail).
//
//     To avoid blocking, the write functions do not do any I/O.  Instead, they
//     save the value passed to them in the corresponding ParamInfo object,
//     change the write state to Pending, wake up the driver's synchronous
//     thread, and then return.
//
//     When the synchronous thread wakes up, it processes any outstanding
//     writes ASAP.  For scalar values, this means the new value is sent right
//     away.  For array values it means it writes the next unsent block of data
//     and causes the thread to run more frequently (to minimize the time
//     needed to complete the writing of all the blocks).
//
//     @note
//        - An array write to persistent memory (PMEM values: The only type
//          supported so far) also changes the read state for the param.  This
//          causes the read value to be updated ASAP following the completion
//          (or failure) of the write operation.
//        - The configuration for array values can include a scalar status
//          parameter that is updated during the read and write operations to
//          indicate the status of the operation (in percent done).
//
//<h3> Read processing: </h3>
//
//     The syncrhonous thread currently reads and processes the current values
//     of all the Read-Only and Write-Anytime registers.  In the future, this
//     functionality will be handled by the asynchronous thread that will
//     handle streaming connections (with the synchronous thread doing it only
//     if there are no active streaming connections updating the same values).
//
//     Each value in a read response is compared to the last processed value,
//     and if it is different, the state of the corresponding ParamInfo object
//     is updated and the new value is posted (written to the asyn layer and
//     callbacks processed for all new values).
//
//<h3> Driver-only values: </h3>
//
//     Parameters can also be defined for driver values that do not represent
//     LCP registers.  In most cases, this is done to provide easy and flexible
//     access to read-only values updated by the driver for diagnostic
//     purposes.  Allowing such values to be accessed via EPICS records means
//     we can leverage the power of all the tools that can be used with EPICS
//     PVs to monitor these values, their behavior over time, and any
//     relationships between them.
//
//=========================================
//
//@subsection ctlr_restart Controller Restarts
//
//=========================================
//
//     One of the register values that each controller is required to support
//     is the upSecs counter, which is reset to 0 whenever the controller is
//     restarted and is incremented by one each second the controller is
//     running.  The driver uses this value to determine if/when the controller
//     was restarted, and to keep track of the date/time it was last known to
//     have restarted.
//
//     When the driver detects that the controller has restarted, it resends
//     all the settings for the write-anytime registers it has gotten since the
//     IOC restarted (including ones restored during IOC initialization).  This
//     insures that the controller is using the last known settings from before
//     it was restarted, avoiding the need to manually reapply all the settings
//     and some possibly nasty surprises because someone turned it back on
//     without noticing that the readbacks indicate it is using default
//     settings.
//
//     Although changes in the upSecs value alone is sufficient to detect
//     controller restarts that occur while the driver is running, doing so
//     across IOC restarts requires more:  The last known upSecs value is
//     useless unless we know the date/time it is relative to.  For this
//     reason, the driver tracks the date/time the controller was last known to
//     have restarted in a read/write parameter named ctlrUpSince (set to:
//     curTime - upSecs).
//
//     Along with most of the write-anytime register values, the driver expects
//     this value to be automatically saved and restored across IOC restarts so
//     it can use it to determine if the controller was restarted since that
//     time. Note that it has to be a writable parameter so it can be restored
//     during IOC startup, but it should NOT allow writing except by the IOC
//     shell.
//
//     @note
//        The ctlrUpSince value and its usage currently does not take in to
//        account whether or not there are Pending writes.  Although it is a
//        low probability, restarting the IOC (but not the controller) when
//        there are Pending writes means the ctlrUpSince value will not change,
//        so any settings that were Pending before the IOC restart will not be
//        sent until the next time the controller restarts.
//
//==================================
//
//@subsection write_access Write Access and Sessions
//
//==================================
//
//     The LCP protocol allows multiple clients to read data from the same
//     device concurrently, but only one client to have write access at any
//     time.
//
//     To gain write access, a client must successfully write a valid number to
//     the sessionID register.  If another client currently has write access,
//     then all such attempts by other clients will fail.
//
//     Once granted, write access is valid for 10 seconds from the time of the
//     client's last successful write operation.  This insures that if the
//     client with the write access becomes idle it does not disable the
//     ability of another client to get write access.
//
//     This also means that, to keep write access, a client must perform a
//     successful write operation at least once every 10 seconds.  At present,
//     the driver keeps track of the last time it did a successful write
//     operation and insures that it does so at least once every 2 seconds.
//
//     Although its existence of the sessionID makes the logic for managing
//     write access simpler, the primary reason it was introduced was to
//     provide a way to detect that the state of the controller changed BEFORE
//     processing affected packets.
//
//     Unlike the upSecs register, the sessionID value is included in every
//     packet the controller sends and the only time it changes should be when
//     the driver changes it.  Any other change indicates that the controller
//     restarted or that another client somehow got the write access.
//
//     What this means is that, for each packet the driver receives, it can
//     determine BEFORE processing the packet whether or not the state of the
//     controller changed.  While potentially useful for synchronous (polling
//     style) communication, it is most useful for the asynchronous (streaming)
//     connections where it is possible to receive an old packet from a
//     previous "session" that may contain outdated information (i.e. from
//     before the sessionID was changed or the controller restarted).  In such
//     cases, the sessionID in the packet will will be different than the value
//     most recently written by the driver, so the driver can choose to discard
//     the packet rather than risk processing outdated values.
//
//
//=====================================================
//
//@subsection communication_problem Communication Problems
//
//=====================================================
//
//     While the sessionID and upSecs values provide the means to determine if
//     the controller restarted, they are of no use unless the IOC is actively
//     communicating with the controller.  If the communication link fails for
//     whatever reason, we won't know whether or not the controller restarted
//     until communication is re-established.
//
//     To detect when there is a persistent problem with the communications
//     link, the driver keeps track of the last time it got a valid response
//     from the controller and periodically checks how long ago that was.  If
//     it has been too long, then the driver considers the controller to be
//     offline (not connected).  When this occurs, the driver changes the
//     status of all the parameters to indicate the problem.
//
//     During IOC initialization the drive must accept writes because that is
//     when settings are restored.  But after that, it rejects write operations
//     whenever the controller is offline.  The reasoning for this is that we
//     have no idea why the controller is offline or how long it will remain
//     offline and we don't want to apply what could be very old settings by
//     the time it comes back online.  The other option (used by the older
//     driver) would be to accept new settings but then discard them if they
//     get too old (although the older driver would then change the settings to
//     match the readings, whereas we might want to store the last value that
//     was successfully sent and revert to that).
//
//     Once normal communication is restored, if the driver discovers that the
//     controller restarted, it will resend all the settings (see the
//     "Controller Restarts" section).
//
**/
